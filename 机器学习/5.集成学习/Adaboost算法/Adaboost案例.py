from numpy import *import matplotlib.pyplot as pltimport pandas as pddef loadDataSet(fileName):    fr = pd.read_csv(fileName, header=None, sep='\t')    dataMat = fr.iloc[:, :-1]    labelMat = fr.iloc[:, -1]    return dataMat,labelMatdef stumpClassify(dataMatrix,dimen,threshVal,threshIneq):     # 对数据进行分类    retArray = ones((shape(dataMatrix)[0],1))    if threshIneq == 'lt':        retArray[dataMatrix[:,dimen] <= threshVal] = -1.0    else:        retArray[dataMatrix[:,dimen] > threshVal] = -1.0    return retArraydef buildStump(dataArr,classLabels,D):    dataMatrix = mat(dataArr); labelMat = mat(classLabels).T    m,n = shape(dataMatrix)    numSteps = 10.0; bestStump = {}; bestClasEst = mat(zeros((m,1)))    minError = inf      # 将初始的错误率定义为无穷大    for i in range(n):    # 迭代所有维度        rangeMin = dataMatrix[:,i].min(); rangeMax = dataMatrix[:,i].max();        stepSize = (rangeMax-rangeMin)/numSteps        for j in range(-1,int(numSteps)+1):  # 在当前维度（特征）下遍历所有数据            for inequal in ['lt', 'gt']:                threshVal = (rangeMin + float(j) * stepSize)                predictedVals = stumpClassify(dataMatrix,i,threshVal,inequal)  #call stump classify with i, j, lessThan                errArr = mat(ones((m,1)))                errArr[predictedVals == labelMat] = 0                weightedError = D.T*errArr  #calc total error multiplied by D                #print("split: dim %d, thresh %.2f, thresh ineqal: %s, the weighted error is %.3f" % (i, threshVal, inequal, weightedError))                if weightedError < minError:                    minError = weightedError                    bestClasEst = predictedVals.copy()                    bestStump['dim'] = i                    bestStump['thresh'] = threshVal                    bestStump['ineq'] = inequal    return bestStump,minError,bestClasEstdef adaBoostTrainDS(dataArr,classLabels,numIt=40):    weakClassArr = []    m = shape(dataArr)[0]    D = mat(ones((m,1))/m)   #init D to all equal    aggClassEst = mat(zeros((m,1)))    for i in range(numIt):        bestStump,error,classEst = buildStump(dataArr,classLabels,D)#build Stump        # print("D:",D.T)        alpha = float(0.5*log((1.0-error)/max(error,1e-16)))#calc alpha, throw in max(error,eps) to account for error=0        # print('α',alpha)        bestStump['alpha'] = alpha          weakClassArr.append(bestStump)                  #store Stump Params in Array        #print("classEst: ",classEst.T)        expon = multiply(-1*alpha*mat(classLabels).T,classEst) #exponent for D calc, getting messy        D = multiply(D,exp(expon))                              #Calc New D for next iteration        D = D/D.sum()        #calc training error of all classifiers, if this is 0 quit for loop early (use break)        aggClassEst += alpha*classEst        #print("aggClassEst: ",aggClassEst.T)        aggErrors = multiply(sign(aggClassEst) != mat(classLabels).T,ones((m,1)))        errorRate = aggErrors.sum()/m        print("total error: ",errorRate)        if errorRate == 0.0: break    return weakClassArr,aggClassEstdef adaClassify(datToClass,classifierArr):    dataMatrix = mat(datToClass)#do stuff similar to last aggClassEst in adaBoostTrainDS    m = shape(dataMatrix)[0]    aggClassEst = mat(zeros((m,1)))    for i in range(len(classifierArr)):        classEst = stumpClassify(dataMatrix,classifierArr[i]['dim'],                                 classifierArr[i]['thresh'],                                 classifierArr[i]['ineq'])#call stump classify        aggClassEst += classifierArr[i]['alpha']*classEst        print(aggClassEst)    return  aggClassEst.ravel(),sign(aggClassEst)def plotROC(predStrengths, classLabels):    cur = (1.0, 1.0)  # cursor    ySum = 0.0  # 用于计算AUC的值    numPosClas = sum(array(classLabels) == 1.0)   #  统计样本中正例的个数    # 在y坐标轴上的步进数目。    yStep = 1 / float(numPosClas)    xStep = 1 / float(len(classLabels) - numPosClas)    sortedIndicies = predStrengths.argsort()  # 数组排序 argsort函数返回的是数组值从小到大的索引值，所以我们从点<1.0, 1.0>开始绘图 直到<0, 0>.    fig = plt.figure()    fig.clf()  # 清空绘图区    ax = plt.subplot(111)    # loop through all the values, drawing a line segment at each point    for index in sortedIndicies.tolist()[0]:   # tolist() 将矩阵转换为list        if classLabels[index] == 1.0:            delX = 0            delY = yStep        else:            delX = xStep            delY = 0            ySum += cur[1]        # draw line from cur to (cur[0]-delX,cur[1]-delY)        ax.plot([cur[0], cur[0] - delX], [cur[1], cur[1] - delY], c='r')        cur = (cur[0] - delX, cur[1] - delY)    ax.plot([0, 1], [0, 1], 'b--')    #  以第一个参数值为横轴，第二个参数值为纵轴    plt.xlabel('False positive rate')    plt.ylabel('True positive rate')    plt.title('ROC curve for AdaBoost horse colic detection system')    ax.axis([-0.1, 1, 0, 1.1])    plt.show()    print("the Area Under the Curve is: ", ySum * xStep)if __name__ == '__main__':    datArr,labelArr = loadDataSet('../datas/horseColicTraining2.txt')    classifierArr,aggClassEst = adaBoostTrainDS(datArr, labelArr, 10)    TestdatArr,TestlabelArr = loadDataSet('../datas/horseColicTest2.txt')    predStrengths,prediction10 = adaClassify(TestdatArr, classifierArr)    print(prediction10)    errArr = mat(ones((67,1)))    print('error rate:',errArr[prediction10 != mat(TestlabelArr).T].sum() / 67.0)    # plotROC(predStrengths, labelArr)